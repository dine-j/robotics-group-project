package version1;

import lejos.hardware.BrickFinder;
import lejos.hardware.Button;
import lejos.hardware.Key;
import lejos.hardware.KeyListener;
import lejos.hardware.lcd.GraphicsLCD;
import lejos.hardware.motor.EV3LargeRegulatedMotor;
import lejos.hardware.motor.EV3MediumRegulatedMotor;
import lejos.hardware.sensor.EV3ColorSensor;
import lejos.hardware.sensor.EV3UltrasonicSensor;
import lejos.hardware.sensor.SensorMode;
import lejos.utility.Delay;

/**
 * 
 * @author k1502837
 *
 *
 * Sensor A:
 */

public class Robot  {
	
	private final int SPEED = 200;
	private final int TURN_SPEED = 80;
	
	private EV3LargeRegulatedMotor motorL, motorR;
	private EV3MediumRegulatedMotor visionMotor;
	
	private EV3ColorSensor colorSensor;
	private SensorMode colorMode;
	private EV3UltrasonicSensor ultrasonicSensor;
	
	private float[] sample;
	
	public Robot(EV3LargeRegulatedMotor motorL, EV3LargeRegulatedMotor motorR, EV3MediumRegulatedMotor visionMotor, EV3ColorSensor colorSensor, EV3UltrasonicSensor ultrasonicSensor) {
		this.motorL = motorL;
		this.motorR	= motorR;
		this.visionMotor = visionMotor;
		this.colorSensor = colorSensor;
		this.ultrasonicSensor = ultrasonicSensor;
		
		setSpeed(SPEED,SPEED);
	}
	
	public void followingLine(int seconds) {
		
		GraphicsLCD g = BrickFinder.getDefault().getGraphicsLCD();
		
		
		
		colorMode = colorSensor.getRedMode();
		sample = new float[colorMode.sampleSize()];
		
		
		float k = -10.0f;
		float offset = 0.3f;
		int tp = 70;
		
		
		
		while (true)
		{
			// takes sample
			colorMode.fetchSample(sample, 0);
			
			float lightVal = sample[0];
			float error = lightVal - offset;
			
			float turn = k * error *10  /* tmp*/;
			float powerL = tp + turn;
			float powerR = tp - turn;
			
			setSpeed((int)powerL, (int)powerR);
			motorL.forward();
			motorR.forward();
			
			g.drawString(sample[0] + " PR:" + (int)powerR + " PL:" + (int)powerL , 0, 0, GraphicsLCD.VCENTER);
			Delay.msDelay(10);
			g.clear();
		}
		
		//
		
		
		
		
		
		//for(int i = 0; i < seconds * 10; ++i) {
		/*while (true){
			// takes sample
			colorMode.fetchSample(sample, 0);
			
			// if sample says white turn right
			if(sample[0] >= RobotMath.ON_WHITE_MIN) {
				g.drawString("RIGHT" + sample[0], 0, 0, GraphicsLCD.VCENTER);
				Delay.msDelay(10);
				g.clear();
				
				turnRight();
			} else if(sample[0] <= RobotMath.ON_LINE_MAX) { // if says black turn left
				g.drawString("LEFT" + sample[0], 0, 0, GraphicsLCD.VCENTER);
				Delay.msDelay(10);
				g.clear();
				
				turnLeft();
			} else {
				g.drawString("FORWARD" + sample[0], 0, 0, GraphicsLCD.VCENTER);
				Delay.msDelay(10);
				g.clear();
				forward();
			
		}}*/
		
		
		//Delay.msDelay(100);
	}
	
	private void turnLeft() {
		setSpeed(TURN_SPEED,SPEED);
		motorL.forward();
		motorR.forward();
	}
	
	private void turnRight() {
		setSpeed(SPEED,TURN_SPEED);
		motorL.forward();
		motorR.forward();
	}
	
	private void forward() {
		setSpeed(SPEED, SPEED);
		motorL.forward();
		motorR.forward();
	}
	
	public boolean senseLine()
	{
		colorMode.fetchSample(sample, 0);
		
		return sample[0] < RobotMath.ON_LINE_MAX;
	}
	
	public void stop() {
		motorL.stop();
		motorR.stop();
	}
	
	public void shutdown() {
		motorL.close();
		motorR.close();
		visionMotor.close();
		colorSensor.close();
		ultrasonicSensor.close();
	}
	
	private void setSpeed(int speedL, int speedR) {
		motorL.setSpeed(speedL);
		motorR.setSpeed(speedR);
	}


	
	
}
